# .Net Troubleshooting

<a id="net-sdk-bulk-load-and-backoff"></a>

## Bulk Load and Exponential Backoff

When you bulk load data to Couchbase Server, you can accidentally overwhelm
available memory in the Couchbase cluster before it can store data on disk. If
this happens, Couchbase Server will immediately send a response indicating the
operation cannot be handled at the moment but can be handled later.

This is sometimes referred to as "handling Temp OOM", where where OOM means out
of memory. Note though that the actual temporary failure could be sent back for
reasons other than OOM. However, temporary OOM is the most common underlying
cause for this error.

To handle this problem, you could perform an exponential backoff as part of your
bulk load. The backoff essentially reduces the number of requests sent to
Couchbase Server as it receives OOM errors:


```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Couchbase;
using Couchbase.Configuration;
using Enyim.Caching.Memcached.Results;
using Enyim.Caching.Memcached;
using System.Threading;

namespace BulkLoader
{
    public class StoreHandler
    {
        CouchbaseClient _cbc;

        public StoreHandler(IList<Uri> uris, string bucketName, string bucketPassword)
        {
            var config = new CouchbaseClientConfiguration();
            foreach (var uri in uris)
            {
                config.Urls.Add(uri);
            }
            config.Bucket = bucketName;
            config.BucketPassword = bucketPassword;

            _cbc = new CouchbaseClient(config);
        }


        /// Perform a  regular Store with storeMode.Set

        public IStoreOperationResult Set(string key, object value)
        {
            return _cbc.ExecuteStore(StoreMode.Set, key, value);
        }

        /// Continuously try a set with exponential backoff until number of tries or
        /// successful.  The exponential backoff will wait a maximum of 1 second, or whatever

        public IStoreOperationResult Set(string key, object value, int tries)
        {
            var backoffExp = 0;
            var tryAgain = false;
            IStoreOperationResult result = null;

            try
            {
                do
                {
                    if (backoffExp > tries)
                    {
                        throw new ApplicationException("Could not perform a set after " + tries + " tries.");
                    }

                    result = _cbc.ExecuteStore(StoreMode.Set, key, value);
                    if (result.Success) break;

                    if (backoffExp > 0)
                    {
                        var backOffMillis = Math.Pow(2, backoffExp);
                        backOffMillis = Math.Min(1000, backOffMillis); //1 sec max
                        Thread.Sleep((int)backOffMillis);
                        Console.WriteLine("Backing off, tries so far: " + backoffExp);
                    }
                    backoffExp++;

                    if (! result.Success)
                    {
                        var message = result.InnerResult != null ? result.InnerResult.Message : result.Message;
                        Console.WriteLine("Failed with status: " + message);
                    }

                    //Future versions of the .NET client will flatten the results and make checking for
                    //InnerResult objects unnecessary
                    tryAgain = (result.Message != null && result.Message.Contains("Temporary failure") ||
                                result.InnerResult != null && result.InnerResult.Message.Contains("Temporary failure"));

                } while (tryAgain);

            }
            catch (Exception ex)
            {
                Console.WriteLine("Interrupted while trying to set.  Exception:" + ex.Message);
            }

            // note that other failure cases fall through.  status.isSuccess() can be
            // checked for success or failure or the message can be retrieved.
            return result;

        }
    }
}
```

<a id="couchbase-sdk-net-operation-results"></a>

# Appendix: Working with Operation Results

The following sections provide details on working with the `IOperationResult`
interface.

`CouchbaseClient` 's standard CRUD operations return `Boolean` values. When
exceptions or failures occur, they are swallowed and `false` is returned.

While there might be scenarios where the cause of a failure is not important
(e.g., non-persistent cache), it is likely that access to error information is
necessary. To that end, the `CouchbaseClient` provides a set of complimentary
ExecuteXXX methods, where XXX is the name of a standard CRUD operation.


```
var success = client.Get("foo"); //returns a Boolean

var result = client.ExecuteGet("foo"); //returns an IOperationResult
```

All ExecuteXXX methods return an instance of an implementation of the
`IOperationResult` interface.


```
public interface IOperationResult
{
    bool Success { get; set; }

    string Message { get; set; }

    Exception Exception { get; set; }

    int? StatusCode { get; set; }

    IOperationResult InnerResult { get; set; }
}
```

For each of the ExecuteXXX methods, a typical use pattern would be to
interrogate the possible error values on failure.


```
var result = client.ExecuteStore(StoreMode.Add, "foo", "bar");

if (! result.Success)
{
    Console.WriteLine("Store operation failed with message {0} and status code {1}", result.Message, result.StatusCode);

    if (result.Exception != null)
    {
        throw result.Exception;
    }
}
```

The `Message` property will contain details as to why an operation failed. The
message might be from the server or it could be from the client. The
`StatusCode` property is a `Nullable<int>` that will be populated from the
server's response.

Note that the 1.1 release of the `OperationResult` API wrapped lower level
(networking) exceptions in an `InnerResult` object. Since release 1.2,
`InnerResult` is no longer populated. The property still remains so as to be
backwards compatible.

Like the standard CRUD methods, the Execute methods will swallow exceptions.
However, caught exceptions are passed back to the caller by way of the
`Exception` property. This allows the caller to check for an exception and throw
it if exception behavior is desired.

There are several interfaces that extend `IOperationResult` to provide
additional properties. Two important interfaces are the
`INullableOperationResult<T>` and `ICasOperationResult`


```
public interface INullableOperationResult<T> : IOperationResult
{
    bool HasValue { get; }
    T Value { get; set; }
}

public interface ICasOperationResult : IOperationResult
{
    ulong Cas { get; set; }
}
```

The `INullableOperationResult<T>` interface is extended by the
`IGetOperationResult`, providing Get operations with properties to get the
retrieved value.


```
var result = client.ExecuteGet("foo");

if (! result.Success)
{
    Console.WriteLine("Get operation failed with message {0} and status code {1}", result.Message, result.StatusCode);

    if (result.Exception != null)
    {
        throw result.Exception;
    }
}

if (result.HasValue)
{
    var value = result.Value;
}
else if (result.StatusCode == 1)
{
    Console.WriteLine("Key does not exist");
}
```

`IGetOperationResult` also extends `ICasOperationResult`. Therefore, it is
possible to get the CAS value from an ExecuteGet operation. The snippet below
demonstrates the generic `ExecuteGet` method.


```
var result = client.ExecuteGet<City>("CT_Hartford");

if (result.Success)
{
    var city = result.Value;
    city.Population = 124775;
    client.ExecuteStore(StoreMode.Set, "CT_Hartford", city, result.Cas); //will fail if Cas is not the same value on server
}
```

`ExecuteStore` methods return `IStoreOperationResult` instances.


```
var result = client.ExecuteStore(StoreMode.Add, "foo", "bar");

if (! result.Success)
{
    Console.WriteLine("Get operation failed with message {0} and status code {1}", result.Message, result.StatusCode);

    if (result.StatusCode == 2)
    {
        Console.WriteLine("Key already exists");
    }

    if (result.Exception != null)
    {
        throw result.Exception;
    }
}
```

`IStoreOperationResult` also extends `ICasOperationResult`. Therefore, it is
possible to get the CAS value from an ExecuteStore operation.


```
var city = new City() { Name = "Hartford", State = "CT" };
var result = client.ExecuteStore(StoreMode.Add, "CT_Hartford", city);

if (result.Success)
{
    city.Population = 124775;
    client.ExecuteStore(StoreMode.Set, "CT_Hartford", city, result.Cas); //will fail if Cas is not the same value on server
}
```

The `IMutateOperationResult`, `IConcatOperationResult` interfaces also return
the CAS value. These interfaces are returned by
`ExecuteIncrement/ExecuteDecrement` and `ExecuteAppend/ExecutePrepend`
respectively. `IRemoveOperationResult` includes only the properties found in
`IOperationResult`.

For more information on which API methods support ExecuteXXX variants, see the
API reference.

<a id="couchbase-sdk-net-json"></a>

# Appendix: JSON Extension Methods

The following sections provide details on how to use the `CouchbaseClient` JSON
extensions.

The `Couchbase.Extensions` namespace contains a series of extension methods that
provide out of the box support for storing and retrieving JSON with Couchbase
Server. These methods use JSON.NET, and provide only limited customization. If
your JSON serialization needs are advanced, you will need to provide your own
methods to work with JSON.

To use the JSON extensions in your application, you'll first need to include a
using block for the extensions namespace


```
using Couchbase.Extensions;
```

Once that using directive has been added, an instance of an `ICouchbaseClient`
will be able to execute various JSON methods.

Generally speaking, for each store or get method, there is a corresponding Json
method.


```
//Person will be stored using binary serialization
    var storeResult = client.ExecuteStore(StoreMode.Set, "person1", new Person { Name = "John" });

    //Person will be stored as a view-ready, JSON string { name : "John" }
    var storeJsonResult = client.ExecuteStoreJson(StoreMode.Set, "person2", new Person { Name = "John" });

    //getResult.Value will contain an instance of a Person
    var getResult = client.ExecuteGet<Person>("person1");

    //InvalidCastException will be thrown, since "person1" contains a binary value
    var getJsonResult = client.ExecuteGetJson<Person>("person1");

    //Invalid cast exception, because person2 contains a string
    var getResult = client.ExecuteGet<Person>("person2");

    //getJsonResult.Value will contain an instance of a Person
    var getJsonResult = client.ExecuteGetJson<Person>("person2");
```

`ExecuteStoreJson` is overloaded to provide support for key expiration, and
durability requirements.


```
var person = new Person { Name = "John" };

    //key will expire in 10 minutes
    var storeJsonResult1 = client.ExecuteStoreJson(StoreMode.Set, "john", person, DateTime.Now.AddMinutes(10));

    //key will expire in 10 minutes
    var storeJsonResult2 = client.ExecuteStoreJson(StoreMode.Set, "john", person, TimeSpan.FromMinutes(10));

    //storeJsonResult3 will fail unless the key is written to disk on its master node, and replicated to two nodes
    var storeJsonResult3 = client.ExecuteStoreJson(StoreMode.Set, "john", person, PersistTo.One, ReplicateTo.Two);
```

CAS operations are also available via the `ExecuteCasJson` extension method.


```
var person = new Person { Name = "John" };

    var getResult = client.ExecuteGetJson("key");
    getResult.Value.Name = "John Z";

    //would fail if the CAS value has changed on the server since it was retrieved
    var casResult = client.ExecuteCasJson(StoreMode.Set, "key", getResult.Value, getResult.Cas);
```

The JSON extensions make an important assumption about your model objects, and
how they serialize and deserialize them. It is important that you understand
this assumption before using these methods. Consider the following Person class:


```
public class Person
{
  public string Id { get; set; }

  public string Type { get { return "person"; } }

  public string Name { get; set; }
}
```

The assumption is that the `Id` property of a domain object is meant to be
mapped to the key in the key/value used to store your data.


```
var person = new Person { Id = "person_12345", Name = "Tony Soprano" };

var storeResult = client.ExecuteStoreJson(StoreMode.Set, person.Id, person);

//the JSON would be:
//{ "name" : "Tony Soprano", type : "person" }
```

When the JSON is saved, it will ignore the `Id` property and its value. Since it
is assumed that the `Id` is the key, it would be redundant to include it in the
saved JSON. Moreover, it would also be a challenge to keep the key in sync with
the JSON.

When the `Person` is retrieved, the `ExecuteGetJson` method will automatically
map the `Id` property to the key. This mapping is achieved by inserting the key
as an "id" property in the JSON document before it is deserialized.


```
var getResult = client.ExecuteGetJson<Person>("person_12345");

Console.WriteLine("Id: " + Person.Id);
//Id: person_12345
```

The importance of how the "id" property is mapped is that you are able to take
advantage of JSON.NET attributes to have some control over which property is
your "Id" property. If you wanted to map the key to a `Key` property, then you
could use the `JsonProperty` attribute as below. Note however, that should you
use this mapping, it will override the ignore "id" on write and you'll have your
key in the JSON.


```
public class Person
{
  [JsonProperty("Id")]
  public string Key { get; set; }

  public string Type { get { return "person"; } }

  public string Name { get; set; }
}
```

The default behavior of the JSON extensions works well with strongly typed
views, which will also map an `Id` property of a class to its key as you iterate
over the view.


```
var view = client.GetView<Person>("people", "by_name", true).Key("Tony Soprano");
var person = view.FirstOrDefault();

Console.WriteLine("Id: " + Person.Id);
//Id: person_12345
```

<a id="couchbase-sdk-net-configuration"></a>

# Appendix: Configuring the.NET Client Library

The following sections provide details on the App|Web.config configuration
options for the.NET Client Library

The `CouchbaseClientSection` class is the configuration section handler.


```
<section name="couchbase" type="Couchbase.Configuration.CouchbaseClientSection, Couchbase"/>
```

The minimum configuration options are to include a `couchbase` section with a
`servers` element with at least one URI, which is used to bootstrap the client.
At least two node URIs should be provided, so that in the event that the client
can't reach the first, it will try the second.

 * `bucket` (default) The bucket against which the client instance will perform
   operations

 * `bucketPassword` The password for authenticated buckets.

 * `username` The username used to secure a cluster.

 * `password` The password associated with the cluster username

 * `retryCount` The number of times to retry a failed attempt to read cluster
   config

 * `retryTimeout` (00:00:02) The amount of time to wait in between failed attempts
   to read cluster config

 * `observeTimeout` (00:01:00) The amount of time to wait for persistence or
   replication checks when using `ExecuteStore` or `ExecuteRemove` with durability
   requirements

 * `httpRequestTimeout` (00:01:00) The amount of time to wait for the HTTP
   streaming connection to receive cluster configuration


```
<couchbase>
    <servers>
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
</couchbase>
```

The "bucket" and "bucketPassword" attributes of the `servers` element default to
"default" and an empty string respectively.


```
<couchbase>
    <servers bucket="default" bucketPassword="H0p$">
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
</couchbase>
```

The client may also be configured in code.


```
var config = new CouchbaseClientConfiguration();
config.Urls.Add(new Uri("http://localhost:8091/pools/"));
config.Bucket = "default";

var client = new CouchbaseClient(config);
```

 * The `socketPool` element is used to configure the behavior of the client as it
   connects to the Couchbase cluster. Defaults are in parentheses. `minPoolSize`
   (10) The minimum number of connections in the connection pool

 * `maxPoolSize` (20) The maximum number of connections in the connection pool

 * `connectionTimeout` (00:00:10) The amount of time the client is waiting to a)
   eastablish a connection to the memcached server, b) get a free connection from
   the pool. If it times out the operation will fail. (And return false or null,
   depending on the operation.)

 * `deadTimeout` (00:00:10) When all pool urls are unavailable the client will
   check the first one again after `deadTimeout` time elapses. Additionally, the
   client has a basic dead node detection mechanism which will also use this
   timeout to reconnect servers which went offline.

 * `queueTimeout` (00:00:00.100) Specifies the amount of time after which the
   getting of a connection from the pool will fail. The default is 100 msec.

 * `receiveTimeout` (00:00:10) The amount of time after which receiving data from
   the socket fails.




```
<couchbase>
    <servers>
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
    <socketPool minPoolSize="10" maxPoolSize="20" />
</couchbase>
```

The client will periodically check the health of its connection to the cluster
by performing a heartbeat check. By default, this test is done every 10 seconds
against the bootstrap URI defined in the `servers` element.

 * `uri` (defaults to first server Uri from `servers` element) The Uri used for the
   heartbeat check

 * `interval` (10000ms) Frequency with which heartbeat check executes

 * `enabled` (true) Enables or disables heartbeat check.




```
<couchbase>
    <servers>
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
    <heartbeatMonitor uri="http://127.0.0.1:8091/pools/heartbeat" interval="60000" enabled="true" />
</couchbase>
```

When executing view queries, the client will make requests over HTTP. That
connection may be managed using the `httpClient` element.

 * `initializeConnection` (true) When true, the `ServicePointManager` is
   initialized asynchronously on client creation rather than on the first view
   request

 * `timeout` (00:01:15) How long to wait for a view request before timing out


```
<couchbase>
    <servers>
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
    <httpClient initializeConnection="false" timeout="00:00:45"/>
</couchbase>
```

When executing view queries, HTTP requests are made by IHttpClient instances
which are created by factories. The factory is defined in the
`httpClientFactory` element.

 * `type` (Couchbase.RestSharpHttpClientFactory, Couchbase) The fully qualified
   type name of an `IHttpClientFactory` implementation,
   `RestSharpHttpClientFactory` is the default. `HammockHttpClientFactory` is also
   supported, but has known issues.


```
<couchbase>
    <servers>
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
    <httpClientFactory type="Couchbase.RestSharpHttpClientFactory, Couchbase" />
</couchbase>
```

When executing view queries, the design document is toggled between dev mode
(prefixed by dev\_) and production mode by setting the `documentNameTransformer`
element.

 * `type` (Couchbase.Configuration.ProductionModeNameTransformer, Couchbase) The
   fully qualified type name of an `INameTransformer` implementation


```
<couchbase>
    <servers>
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
    <documentNameTransformer type="Couchbase.Configuration.ProductionModeNameTransformer, Couchbase" />
</couchbase>
```

The `keyTransformer` is used to normalize/validate the item keys before sending
them to the server.

 * `type` (Enyim.Caching.Memcached.DefaultKeyTransformer) must be the fully
   qualified name of a type implementing `IMemcachedKeyTransformer`

 * `factory` must be the fully qualified name of a type implementing
   `IProviderFactory<IMemcachedKeyTransformer>`


```
<couchbase>
    <servers>
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
    <keyTransformer type="Enyim.Caching.Memcached.DefaultKeyTransformer, Enyim.Caching" />
</couchbase>
```

The `transcoder` is used to serialize stored/retrieved objects.

 * `type` (Enyim.Caching.Memcached.DefaultKeyTransformer) must be the fully
   qualified name of a Type implementing `ITranscoder`

 * `factory` must be the fully qualified name of a type implementing
   `IProviderFactory<ITranscoder>`


```
<couchbase>
    <servers>
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
    <keyTransformer type="Enyim.Caching.Memcached.DefaultTranscoder, Enyim.Caching" />
</couchbase>
```

The `transcoder` is used to map objects to servers in the pool.

 * `type` (Enyim.Caching.Memcached.DefaultKeyTransformer) must be the fully
   qualified name of a type implementing `IMemcachedNodeLocator`

 * `factory` must be the fully qualified name of a type implementing
   `IProviderFactory<IMemcachedNodeLocator>`


```
<couchbase>
    <servers>
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
    <keyTransformer type="Enyim.Caching.Memcached.DefaultNodeLocator, Enyim.Caching" />
</couchbase>
```

It is not possible to configure (in app|web.config) a single instance of a
CouchbaseClient to work with multiple buckets. Though it is possible to
programmatically reconstruct a client to work with multiple buckets, it is not
recommended. The process of creating a client is expensive (relative to other
Couchbase operations) and should ideally be done once per app domain.

It is possible however to set multiple config sections in app|web.config to
allow for multiple client instances to be created, while still maintaining
bucket affinity.


```
<?xml version="1.0"?>
<configuration>
  <configSections>
    <sectionGroup name="couchbase">
      <section name="bucket-a" type="Couchbase.Configuration.CouchbaseClientSection, Couchbase"/>
      <section name="bucket-b" type="Couchbase.Configuration.CouchbaseClientSection, Couchbase"/>
    </sectionGroup>
  </configSections>

  <couchbase>
    <bucket-a>
      <servers bucket="default">
        <add uri="http://127.0.0.1:8091/pools" />
      </servers>
    </bucket-a>
    <bucket-b>
      <servers bucket="beernique" bucketPassword="b33rs">
        <add uri="http://127.0.0.1:8091/pools" />
      </servers>
    </bucket-b>
  </couchbase>

  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0"/>
  </startup>
</configuration>
```

After defining the config sections, bucket specific clients are created by
reading the appropriate config sections and passing the config section reference
to the constructor of the CouchbaseClient. Again, constructing the client should
not be done per operation, but rather per app domain.


```
var bucketASection = (CouchbaseClientSection)ConfigurationManager.GetSection("couchbase/bucket-a");
var bucketBSection = (CouchbaseClientSection)ConfigurationManager.GetSection("couchbase/bucket-b");

var clientA = new CouchbaseClient(bucketASection);
var clientB = new CouchbaseClient(bucketBSection);

clientA.ExecuteStore(StoreMode.Set, "fooA", "barA");
var itemA = clientA.Get<string>("fooA");
Console.WriteLine(itemA);

clientB.ExecuteStore(StoreMode.Set, "fooB", "barB");
var itemB = clientB.Get<string>("fooB");
Console.WriteLine(itemB);
```

<a id="couchbase-sdk-net-logging"></a>

# Appendix: Configuring Logging

The following sections provide details on how to enable logging for the.NET
Client Library

To enable logging, you can tap into the logging capabilities provided by the
Enyim.Caching dependency. Enyim logging currently supports either log4net or
NLog.

Start by adding a reference to either Enyim.Caching.Log4NetAdapter or
Enyim.Caching.NLogAdapter. Both are available as part of the part of the client
library zip file, or as separate NuGet packages.

To install via NuGet, look for either the CouchbaseLog4NetAdapter or
CouchbaseNLogAdapter package.

You could also get the projects from
[](https://github.com/couchbase/couchbase-net-client). If you use these Visual
Studio projects, you'll need NuGet installed, as dependencies to NLog and
log4Net are managed using NuGet.

For log4net, your configuration should include an enyim.com section that defines
which log factory to use along with standard log4net configuration.

The log4net configuration will vary by the type of appender you are using. For
more information on log4net configuration, see
[](http://logging.apache.org/log4net/release/manual/configuration.html).


```
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <configSections>
    <sectionGroup name="enyim.com">
      <section name="log" type="Enyim.Caching.Configuration.LoggerSection, Enyim.Caching" />
    </sectionGroup>
    <section name="log4net" type="log4net.Config.Log4NetConfigurationSectionHandler, log4net" />
  </configSections>
  <enyim.com>
    <log factory="Enyim.Caching.Log4NetFactory, Enyim.Caching.Log4NetAdapter" />
  </enyim.com>
  <log4net debug="false">
    <appender name="LogFileAppender" type="log4net.Appender.FileAppender,log4net">
      <param name="File" value="c:\\temp\\error-log.txt" />
      <param name="AppendToFile" value="true" />
      <layout type="log4net.Layout.PatternLayout,log4net">
        <param name="ConversionPattern" value="%d [%t] %-5p %c [%x] &lt;%X{auth}&gt; - %m%n" />
      </layout>
    </appender>
    <root>
      <priority value="ALL" />
      <level value="DEBUG" />
      <appender-ref ref="LogFileAppender" />
    </root>
  </log4net>
</configuration>
```

You'll also need to initialize (only once in your app) log4net in your code with
the standard log4net initializer.


```
log4net.Config.XmlConfigurator.Configure();
```

NLog configuration requires setting the log factory to NLogAdapter and including
the appropriate NLog configuration section.


```
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <configSections>
    <sectionGroup name="enyim.com">
      <section name="log" type="Enyim.Caching.Configuration.LoggerSection, Enyim.Caching" />
    </sectionGroup>
    <section name="nlog" type="NLog.Config.ConfigSectionHandler, NLog" />
  </configSections>
  <enyim.com>
    <log factory="Enyim.Caching.NLogFactory, Enyim.Caching.NLogAdapter" />
  </enyim.com>
  <nlog>
    <targets>
      <target name="logfile" type="File" fileName="c:\temp\error-log.txt" />
    </targets>
    <rules>
      <logger name="*" minlevel="Info" writeTo="logfile" />
    </rules>
  </nlog>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0" />
  </startup>
</configuration>
```

See [](http://nlog-project.org/wiki/Configuration_file) for more NLog
configuration details.

<a id="couchbase-sdk-net-cluster-management"></a>

# Appendix: Cluster Management with the.NET Client Library

The following sections provide details about using the Couchbase.NET Client to
manage buckets and design documents.

Cluster management is performed by using methods of the `CouchbaseCluster`
class, which implements the `ICouchbaseCluster` interface, both of which are in
the `Couchbase.Management` namespace.


```
using Couchbase.Management;
```

The `CouchbaseCluster` is configured using the same config definitions (code or
XML) used to create instances of a `CouchbaseClient`. When managing the cluster
with the.NET client, the cluster username and password must be provided.


```
<couchbase>
    <servers username="Administrator" password="qwerty" >
      <add uri="http://127.0.0.1:8091/pools"/>
    </servers>
</couchbase>
```



The default constructor for `CouchbaseCluster` looks for a section named
"couchbase". It is possible to use a named section, as follows:


```
var config = ConfigurationManager.GetSection("anothersection") as CouchbaseClientSection;
var cluster = new CouchbaseCluster(_config);
```

To configure `CouchbaseCluster` in code, pass an instance of an
`ICouchbaseClientConfiguration` to the constructor.


```
var config = new CouchbaseClientConfiguration();
config.Urls.Add(new Uri("http://localhost:8091/pools/"));
config.Username = "Administrator";
config.Password = "qwerty";

var cluster = new CouchbaseCluster(config);
```

 * To get a list of buckets from the server, there are two methods. `Bucket[]
   ListBuckets()` returns an array of Bucket instances, one for each bucket in the
   cluster

 * `bool TryListBuckets(out Bucket[] buckets)` returns true when no errors and
   provides the list of buckets as an out param. When errors occur, returns false
   and a null buckets array

 * To get a single of bucket from the server, there are two methods. `Bucket
   GetBucket(string bucketName)` returns a Bucket instance for a bucket with the
   given name

 * `bool TryGetBucket(string bucketName, out Bucket bucket)` returns true when no
   errors and provides the named bucket as an out param. When errors occur, returns
   false and a null bucket

 * To get the count of items in a bucket, or across buckets use the following
   methods: `long GetItemCount(string bucketName)` returns the count of items in a
   bucket with the given name

 * `long GetItemCount()` returns the count of items in all buckets in a cluster

 * To get the count of items in a bucket, or across buckets use the following
   methods: `long GetItemCount(string bucketName)` returns the count of items in a
   bucket with the given name

 * `long GetItemCount()` returns the count of items in all buckets in a cluster

 * To manage the buckets in a cluster, there are three methods. `void
   CreateBucket(Bucket bucket)` create a bucket with the given bucket properties

    ```
    //create an authenticated Couchbase bucket
    cluster.CreateBucket(
        new Bucket
            {
                Name = "newBucket",
                AuthType = AuthTypes.Sasl,
                BucketType = BucketTypes.Membase,
                Quota = new Quota { RAM = 100 },
                ReplicaNumber = ReplicaNumbers.Zero
            }
    );

    //create an unauthenticated Couchbase bucket
    cluster.CreateBucket(
        new Bucket
            {
                Name = "newBucket",
                AuthType = AuthTypes.None,
                BucketType = BucketTypes.Membase,
                Quota = new Quota { RAM = 100 },
                ProxyPort = 9090,
                ReplicaNumber = ReplicaNumbers.Two
            }
    );

    //create a memcached bucket
    cluster.CreateBucket(
        new Bucket
        {
          Name = "newBucket",
             AuthType = AuthTypes.None,
             BucketType = BucketTypes.Memcached,
             Quota = new Quota { RAM = 100 },
             ProxyPort = 9090,
             ReplicaNumber = ReplicaNumbers.Zero
        }
    );
    ```

 * `void UpdateBucket(Bucket bucket)` recreates an existing bucket, updating only
   changed parameters.

    ```
    cluster.UpdateBucket(
        new Bucket
        {
          Name = "newBucket",
             Quota = new Quota { RAM = 128 },
             ProxyPort = 9090,
             AuthType = AuthTypes.None
        }
    );
    ```

 * `void DeleteBucket(string bucketName)` deletes an existing bucket

    ```
    cluster.DeleteBucket("bucketName");
    ```

 * To remove the data (but not design documents) from a bucket, use the
   `FlushBucket` method. `void FlushBucket(string bucketName)` flushes data from a
   bucket

    ```
    cluster.FlushBucket("bucketName");
    ```

 * There are four methods for managing design documents with the
   `CouchbaseCluster`. `bool CreateDesignDocument(string bucket, string name,
   string document)` creates a design document on the server, using the provided
   JSON string as the source of the document.

    ```
    //create a production mode design document
    var json =
    @"{
        ""views"": {
            ""by_name"": {
                ""map"": ""function (doc) { if (doc.type == \""city\"") { emit(doc.name, null); } }""
            }
        }
    }";

    var result = cluster.CreateDesignDocument("default", "cities", json);

    //create the same view using development mode
    var devResult = custer.CreateDesignDocument("default", "dev_cities", json);
    ```

 * `bool CreateDesignDocument(string bucket, string name, Stream source)` create a
   design document on the server using a readable `Stream` instance as the source
   of the document.

    ```
    var stream = new FileStream("Data\\CityViews.json", FileMode.Open);
    var result = cluster.CreateDesignDocument("default", "cities", stream);
    ```

 * `string RetrieveDesignDocument(string bucket, string name)` Retreive a design
   document from a bucket

    ```
    var document = cluster.RetrieveDesignDocument("default", "cities");
    ```

 * `bool DeleteDesignDocument(string bucket, string name)` Deletes a design
   document from a bucket

    ```
    var result = cluster.DeleteDesignDocument("default", "cities");
    ```



<a id="couchbase-sdk-net-available-packages"></a>

# Appendix: Available packages for the.NET Client Library

The following sections provide details about the various Couchbase packages
available on NuGet, and via direct download.

The official Client Library and associated loggers are both available as.NET 3.5
and.NET 4.0 builds. When you download the zip file, there are directories for
each framework version. The NuGet package contains both 3.5 and 4.0 binaries.

 * `CouchbaseNetClient` Contains the latest `Couchbase` and `Enyim.Caching`
   assemblies. `Newtonsoft.Json` is a dependency.

 * `CouchbaseNLogAdapter` Contains the latest `NLog` logging adapter, built against
   the Couchbase fork of `Enyim.Caching`. Installing the `EnyimMemcached-NLog`
   package will lead to a build conflict in your project. `CouchbaseNetClient` and
   `NLog` are dependencies.

 * `CouchbaseLog4NetAdapter` Contains the latest `log4net` logging adapter, built
   against the Couchbase fork of `Enyim.Caching`. Installing the
   `EnyimMemcached-log4net` package will lead to a build conflict in your project.
   `CouchbaseNetClient` and `log4net` are dependencies.

 * `CouchbaseHttpClients` Contains the latest `RestSharp` and `Hammock` view HTTP
   clients. These clients are legacy. The latest `CouchbaseClient` uses the BCL
   `WebClient`. `CouchbaseNetClient`, `RestSharp`, and `Hammock` are dependencies.
   These assemblies are unsigned, due to the NuGet package for `RestSharp` being
   unsigned.

Several integration packages are also available via NuGet.

 * `Couchbase ASP.NET SessionState and OutputCache Providers` allows Couchbase to
   be used as an out of process session state provider, and output caching
   provider.

 * `CouchbaseElmahErrorLog` allows ELMAH error logs to be stored in Couchbase.

 * `CouchbaseSnippets` adds some basic Visual Studio snippets.

 * `CouchbaseNHibernateCache` allows Couchbase to be used as an NHibernate second
   level cache.

 * `Couchbase Model Views` allows classes to be decorated with attributes used to
   create simple, and complex views without writing map functions.

   `Glimpse for Couchbase` allows `CouchbaseClient` logs to be viewable via a
   Glimpse tab.

If not using NuGet, the lastest binaries are available as a direct download at
[](https://www.couchbase.com/develop/net/current/). The download package
contains the `CouchbaseClient`, and `Enyim.Caching` assemblies. The
`Newtonsoft.Json`, `NLog`, and `log4net` dependencies are also included.

<a id="couchbase-sdk-net-rn"></a>

# Appendix: Release Notes

The following sections provide release notes for individual release versions of
Couchbase Client Library.NET. To browse or submit new issaues, see [Couchbase
Client Library.NET Issues Tracker](http://www.couchbase.com/issues/browse/NCBC).

<a id="couchbase-sdk-net-rn_1-2-6a"></a>

## Release Notes for Couchbase Client Library.NET 1.2.6 GA (07 May 2013)

.NET Couchbase Client 1.2.6 fixes an issue where the 1.2.5 NuGet package
contained an unsigned Enyim.Caching assembly (3.5 only). The 4.0 NuGet package
was not affected.

<a id="couchbase-sdk-net-rn_1-2-5a"></a>

## Release Notes for Couchbase Client Library.NET 1.2.5 GA (07 May 2013)

.NET Couchbase Client 1.2.5 removes the RestSharp and Hammock dependencies, adds
support for.NET 3.5, along with new features and bug fixes.

**New Features and Behaviour Changes in 1.2.5**

 * NCBC-231: Support for Unlock without CAS operation

    ```
    var lockResult = client.ExecuteGetWithLock("key", TimeSpan.FromSeconds(20));

     var storeResult = client.ExecuteStore(StoreMode.Set, "key", "new value");
     Assert.That(storeResult.Success, Is.False);

     var unlockResult = client.ExecuteUnlock("key"); //unlock before the timeout
     //may also use Boolean form (e.g., var boolVal = client.Unlock("key");
     Assert.That(unlockResult.Success, Is.True);

     var storeResult2 = client.ExecuteStore(StoreMode.Set, "key", "another new value");
     Assert.That(storeResult.Success, Is.True);
    ```

 * The logging assemblies are now available via separate NuGet pacakges, which
   reference NLog and log4net via NuGet, instead of local assemblies. See
   CouchbaseLog4NetAdapter and CouchbaseNLogAdapater on NuGet.

 * NCBC-254: JSON extensions should default to ignore Id property on
   add/replace/set. This change allows for compatibility with the generic view
   queries, which map the key to an Id property.

    ```
    var thing = new Thing { Id = key, SomeProperty = "Foo", SomeOtherProperty = 17 };
     var result = _Client.StoreJson(StoreMode.Set, key, thing);
     Assert.That(result, Is.True);

     //An "Id" property will be removed from the stored JSON
     var obj = _Client.Get<string>(key);
     Assert.That(obj, Is.Not.StringContaining("\"id\""));

     //GetJson will automatically assign the key to an Id property
     var savedThing = _Client.GetJson<Thing>(key);
     Assert.That(savedThing.Id, Is.StringContaining(key));
    ```

 * NCBC-246: The.NET Client Library is now code compatible with the.NET Framework
   version 3.5. The NuGet package and release zip file contain both 4.0 and 3.5
   assemblies. The solution (see GitHub) now includes a Couchbase.Net35 project.

 * NCBC-247: RestSharp and Hammock are no longer dependencies of the Couchbase.NET
   Client Library.

   No change should be necessary, unless using explicit RestSharp or Hammock
   configuration for the HttpClientFactory. If not, the default configuration will
   use the new HttpClientFactory, which relies only on WebClient. In 1.2.4, the
   default HttpClientFactory relied on RestSharp.

   RestSharp and Hammock will be usable via a separate NuGet project, or from the
   Couchbase.HttpClients project (via GitHub). These assemblies will not be signed,
   to avoid collisions with a custom RestSharp, which is unsigned.

**Fixes in 1.2.5**

 * NCBC-256: Throw exception when lock expiry exceeds server limit (30 seconds)

    ```
    try {
     var lockResult = client.ExecuteGetWithLock("key", TimeSpan.FromSeconds(40));
     } catch (ArgumentOutOfRangeException ex) {
     //handle exception
     }
    ```

<a id="couchbase-sdk-net-rn_1-2-4a"></a>

## Release Notes for Couchbase Client Library.NET 1.2.4 GA (02 April 2013)

.NET Couchbase Client 1.2.4 adds support for Get with Lock feature, along with
bug fixes.

**New Features and Behaviour Changes in 1.2.4**

 * NCBC-238: Support for key exists check without getting value.

   Observe is used behind the scenes to support the check. `KeyExists` method
   checks that key is either in `FoundPersisted` or `FoundNotPersisted` state on
   master node.

    ```
    var exists = client.KeyExists("foo");
    ```

 * NCBC-231: Support for Get with Lock

    ```
    var lockResult = client.ExecuteGetWithLock("key", TimeSpan.FromSeconds(30));
     var storeResult = client.ExecuteStore(StoreMode.Set, "key", "new value");
     Assert.That(storeResult.Success, Is.False);
     Assert.That(storeResult.StatusCode.Value, Is.EqualTo((int)StatusCodeEnums.DataExistsForKey));

     //or
     var getLockResultA = client.ExecuteGetWithLock("key");
     var getLockResultB = client.ExecuteGetWithLock("key");
     Assert.That(getLockResultB.StatusCode, Is.EqualTo((int)CouchbaseStatusCodeEnums.LockError));
    ```

**Fixes in 1.2.4**

 * NCBC-239: Fix to set `RestSharpHttpClient.Timeout` property correctly. Was
   previously being set to `TimeSpan.Milliseconds` instead of total
   `TimeSpan.Milliseconds`.

 * NCBC-243: Fix to fail store operations when `PersistTo` or `ReplicateTo`
   durability requirements could not be satisfied by number of online nodes.

<a id="couchbase-sdk-net-rn_1-2-3a"></a>

## Release Notes for Couchbase Client Library.NET 1.2.3 GA (08 March 2013)

.NET Couchbase Client 1.2.3 GA addresses an invalid strong name issue with
Enyim.Caching in release 1.2.2.

<a id="couchbase-sdk-net-rn_1-2-2a"></a>

## Release Notes for Couchbase Client Library.NET 1.2.2 GA (05 March 2013)

.NET Couchbase Client 1.2.2 GA provides stability fixes and new API methods.

**New Features and Behaviour Changes in 1.2.2**

 * NCBC-229: Support Remove with CAS operation.

    ```
    var getResult = client.ExecuteGet("key");
     var removeResult = client.ExecuteRemove("key", getResult.Cas);
    ```

**Fixes in 1.2.2**

 * NCBC-234: Fix to include CAS on return of ExecuteGetJson extension method.

 * NCBC-228: Fix for concurrency issues during rebalance lead to frequent
   PooledSocket errors.

**Known Issues in 1.2.2**

 * The 1.2.2 release contains an Enyim.Caching assembly with an invalid strong
   name.

<a id="couchbase-sdk-net-rn_1-2-1a"></a>

## Release Notes for Couchbase Client Library.NET 1.2.1 GA (05 February 2013)

.NET Couchbase Client 1.2.1 GA provides stability fixes and new API methods.

**New Features and Behaviour Changes in 1.2.1**

 * NCBC-165: IView now includes a `CheckExists` method, which will allow callers to
   verifiy that a view exists in a design document prior to executing a view query.
   This method will perform an HTTP request to get the design document contents.

    ```
    var view = client.GetView("cities", "by_name");

     if (view.CheckExists())
     {
     foreach(var item in view)
     {
     //do something
     }
     }
    ```

 * NCBC-179: Additional JSON extensions are now available. For each Store or
   ExecuteStore method in the `ICouchbaseClient` API, there is now a corresponding
   JSON method. These additions include methods for CAS and expiry overloads. An
   `ExecuteGetJson` method has also been provided. Note these methods are
   intentionally not included in the `ICouchbaseClient` interface as they are
   explicitly tied to Newtonsoft.Json and its default serialization rules.

    ```
    //store
     var city = new City { Name = "Hartford", State = "CT", Type = "city" };
     var result = client.ExecuteStoreJson(StoreMode.Set, "city_Hartford_CT", city, DateTime.Now.AddMinutes(30));
     //get
     var otherCity = client.ExecuteGetJson<City>("city_Bridgeport_CT");
    ```

 * NCBC-159: Support for getting debug info from views.

    ```
    var view = client.GetView("cities", "by_name").Debug(true);
     view.Count(); //need to execute the query to get debug info
     var local = view.DebugInfo["local"]; //DebugInfo is a dictionary
    ```

 * NCBC-190: `CouchbaseCluster` now has method FlushBucket. Creating buckets with
   flush enabled is also supported.

    ```
    var cluster = new CouchbaseCluster(config);
     cluster.CreateBucket(new Bucket
     {
     Name = "transaction",
     AuthType = AuthTypes.Sasl,
     BucketType = BucketTypes.Membase,
     Quota = new Quota { RAM = 100 },
     ReplicaNumber = ReplicaNumbers.Zero,
     FlushOption = FlushOptions.Enabled
     });
     //and flushing
     cluster.FlushBucket("transaction");
    ```

**Fixes in 1.2.1**

 * NCBC-166: The `DefaultKeyTransformer` no longer forbids chars 0x00-0x20 and
   space. To provide support for legacy Memcached key rules, the
   `LegacyMemcachedKeyTransformer` may be used.

    ```
    <keyTransformer type="Enyim.Caching.Memcached.LegacyMemcachedKeyTransformer, Enyim.Caching" />
    ```

 * NCBC-189: Fix to NRE when ExecuteIncrement or ExecuteDecrement returned null
   `StatusCode`.

 * NCBC-195: NRE no longer thrown when client cannot locate a node on which to
   execute a view. The lack of available nodes is logged in the debug log and an
   InvalidOperationException is intentionally raised. NCBC-222: is tracking a 1.2.2
   fix for an improved exception type.

 * NCBC-172: 1.2.0 Hammock dependency was throwing a null reference exception when
   executing a view query against an offline node. The 1.2.1 release replaces
   Hammock with RestSharp for view execution. Hammock is still supported, but
   RestSharp is the new default. If Hammock is explicitly configured, then Hammock
   will still be used for view execution. RestSharp is the suggested view REST
   library. To ensure RestSharp is in use, App|Web.config must not contain snippet
   below. If configured in code, the HttpClientFactory should not be set.

    ```
    <httpClientFactory type="Couchbase.HammockHttpClientFactory, Couchbase" />
    ```

 * NCBC-197: When 0 bytes are received on sockets, but read was valid, Enyim client
   was throwing an exception with the message "?." A descriptive exception message
   is now included.

 * NCBC-192: NRE was being thrown when executing ops against a down node. NRE was
   also the symptom displayed when app client configuration was incorrect. Ops
   against a bad node should now return the message "Unable to locate node" when
   using the `IOperationResult` methods. There is a constant for this error.

    ```
    var result = client.ExecuteGet("somekey");
    if (! result.Success && result.Message == ClientErrors.FAILURE_NODE_NOT_FOUND)
    {
     //couldn't reach the node, check config if first run of app
    }
    ```

 * NCBC-212: `ExecuteRemove` is no longer swallowing status codes on errors.
   `StatusCode` property was always null previously on errors.

**Known Issues in 1.2.1**

 * NCBC-223: Mono support not included for 1.2.1.
   ServicePointManager.SetTcpKeepAlive is not supported by Mono. A 1.2.0 build was
   released with this call removed, however a better solution should be in place
   for 1.2.2.

<a id="couchbase-sdk-net-rn_1-2-0g"></a>

## Release Notes for Couchbase Client Library.NET 1.2.0 GA (12 December 2012)

Couchbase Client 1.2 GA is the first GA release to support Couchbase Server 2.0.
1.2 is backwards compatible with Couchbase Server 1.8.

In addition to support for new features of Couchbase Server 2.0, the
Couchbase.NET Client Library 1.2 adds stability improvements to iteself and its
dependent Enyim.Caching library.

The Couchbase.NET Client Library 1.2 requires the.NET Framework 4.0 or higher.

**Fixes in 1.2.0**

 * NCBC-168: Socket errors were previously being swallowed and did not bubble up
   through ExecuteXXX method return values.

 * NCBC-161: Run views only on nodes in cluster supporting couchApiBase (Couchbase
   nodes)

**Known Issues in 1.2.0**

 * NCBC-172: During a rebalance or fail over, view queries may result in an
   unhandled NullReferenceException. This exception is raised by a thread in the
   dependency Hammock.

 * NCBC-170: If an exception occurs before data are read, the PooledSocket may be
   returned to the pool marked still alive and with a dirty buffer. In some
   situations, a wrong magic value error may result.

 * NCBC-176: Flushing of buckets is not yet supported in Couchbase.Management API

<a id="couchbase-sdk-net-rn_1-2-0f"></a>

## Release Notes for Couchbase Client Library.NET 1.2.0-BETA-3 Beta (28 November 2012)

**New Features and Behaviour Changes in 1.2.0-BETA-3**

 * New CouchbaseCluster GetItemCount method (NCBC-92)

 * View timeout is now configuragble (NCBC-158)

 * Implemented remove with observe (NCBC-163)

 * ListBucket object graph now matches full server JSON (NCBC-142)

 * New UpdateBucket method on CouchbaseCluster (NCBC-143)

 * ICouchbaseClient interface completed to match CouchbaseClient public methods
   (NCBC-151)

 * Auto-map Id property to "id" field in view rows on generic view queries
   (NCBC-154)

 * Debug now supported as view parameter (NCBC-159)

 * Add support to build under Mono (NCBC-132)

 * (Experimental) support for spatial views (NCBC-47).

 * New CouchbaseCluster GetBucket and TryGetBucket methods to get single bucket
   (NCBC-72)

**Fixes in 1.2.0-BETA-3**

 * ExecuteGet no longer reports "failed to locate node" on cache misses (NCBC-130)

 * Don't swallow pooled socket errors (NCBC-168)

 * View requests are now made to a randomly selected node from cluster (NCBC-146)

 * Observe reliability fixes (NCBC-129, NCBC-128, NCBC-124, NCBC-127)

 * Failed bootstrap node no longer puts client in invalid state (NCBC-134).

 * Null reference exceptions now longer (occasionally) thrown during rebalancing.

 * Updated Enyim submodule reference to latest commit (NCBC-167)

 * Pre-fetch views to cache network pools for view requests (NCBC-149)

 * Client now handles correctly -1 vbucket indexes in cluster config (NCBC-148)

 * Null reference exceptions now longer (occasionally) thrown during rebalancing
   (NCBC-121).

 * HTTP and connection timeouts are now separate (NCBC-34)

 * Deleted keys return null during generic view queries with non-stale iterations
   (NCBC-157)

 * Delete bucket handles 500 error from server (NCBC-119)

 * No longer disposing Timer in heartbeat check when it's disabled (NCBC-136)

**Known Issues in 1.2.0-BETA-3**

 * Delete bucket request succeeds but exception is thrown.

<a id="couchbase-sdk-net-rn_1-2-0d"></a>

## Release Notes for Couchbase Client Library.NET 1.2.0-DP4 Alpha (27 August 2012)

**New Features and Behaviour Changes in 1.2.0-DP4**

 * New bucket administration methods

    ```
    var cluster = new CouchbaseCluster("couchbase"); //name of config section with credentials
     cluster.CreateBucket(new Bucket { ... });
     var buckets = cluster.ListBuckets();
     cluster.DeleteBucket();
    ```

 * New, basic JSON conversion extension methods for serializing objects to and from
   JSON. Methods use Newtonsoft.Json for JSON conversions.

    ```
    using Couchbase.Extensions;
     var result = client.StoreJson<Beer>(StoreMode.Set, "foo", new Beer { ... });
     var beer = client.GetJson<Beer>("foo");
    ```

 * 1.2.0 specific configuration elements (HttpClientFactory and
   DocumentNameTransformer) now have defaults and 1.1 configuration will work with
   1.2.0.

    ```
    using Couchbase.Extensions;
     var result = client.StoreJson<Beer>(StoreMode.Set, "foo", new Beer { ... });
     var beer = client.GetJson<Beer>("foo");
    ```

 * New design document administration methods

    ```
    var cluster = new CouchbaseCluster("couchbase"); //name of config section with credentials
     cluster.CreateDesignDocument("bucketname", "{ ... }");
     var designDoc = cluster.RetrieveDesignDocument("bucketname", "designdocname");
     cluster.DeleteDesignDocument("bucketname", "designdocname");
    ```

**Fixes in 1.2.0-DP4**

 * Observe tests no longer fail on multi-node persistence/replication checks.

<a id="couchbase-sdk-net-rn_1-2-0c"></a>

## Release Notes for Couchbase Client Library.NET 1.2.0-DP3 Alpha (27 August 2012)

**New Features and Behaviour Changes in 1.2.0-DP3**

 * Initial implementation of Observe and Store with durability checks.

    ```
    //check for master persistence
     var result = client.ExecuteStore(StoreMode.Set, "foo", "bar", PersistTo.One);

     //check for master persistence with replication to 2 nodes
     var result = client.ExecuteStore(StoreMode.Set, "foo", "bar", PersistTo.One, ReplicateTo.Two);
    ```

**Known Issues in 1.2.0-DP3**

 * Multi-node persistence/replication checks fail sporadically on observe.

<a id="couchbase-sdk-net-rn_1-2-0b"></a>

## Release Notes for Couchbase Client Library.NET 1.2.0-DP2 Alpha (25 July 2012)

**Fixes in 1.2.0-DP2**

 * Generic view requests no longer emitting the original document as value. Client
   Get method is used instead to retrieve original document.

 * Reduced views no longer break from missing "id" field in row.

 * Paging no longer breaks.

 * DevelopmentModeNameTransformer now correctly prepends dev\_ on view requests.

<a id="couchbase-sdk-net-rn_1-2-0a"></a>

## Release Notes for Couchbase Client Library.NET 1.2-DP Alpha (27 March 2012)

**New Features and Behaviour Changes in 1.2-DP**

 * Initial support for Couchbase Server 2.0 view API.

    ```
    var view = client.GetView("designdoc", "viewname");
     foreach(var item in view)
     {
     Console.WriteLine(item.ItemId);
     }
    ```

 * Couchbase.dll is now compiled against the.NET Framework 4.0

<a id="licenses"></a>

# Appendix: Licenses

This documentation and associated software is subject to the following licenses.

<a id="license-documentation"></a>

## Documentation License

This documentation in any form, software or printed matter, contains proprietary
information that is the exclusive property of Couchbase. Your access to and use
of this material is subject to the terms and conditions of your Couchbase
Software License and Service Agreement, which has been executed and with which
you agree to comply. This document and information contained herein may not be
disclosed, copied, reproduced, or distributed to anyone outside Couchbase
without prior written consent of Couchbase or as specifically provided below.
This document is not part of your license agreement nor can it be incorporated
into any contractual agreement with Couchbase or its subsidiaries or affiliates.

Use of this documentation is subject to the following terms:

You may create a printed copy of this documentation solely for your own personal
use. Conversion to other formats is allowed as long as the actual content is not
altered or edited in any way. You shall not publish or distribute this
documentation in any form or on any media, except if you distribute the
documentation in a manner similar to how Couchbase disseminates it (that is,
electronically for download on a Web site with the software) or on a CD-ROM or
similar medium, provided however that the documentation is disseminated together
with the software on the same medium. Any other use, such as any dissemination
of printed copies or use of this documentation, in whole or in part, in another
publication, requires the prior written consent from an authorized
representative of Couchbase. Couchbase and/or its affiliates reserve any and all
rights to this documentation not expressly granted above.

This documentation may provide access to or information on content, products,
and services from third parties. Couchbase Inc. and its affiliates are not
responsible for and expressly disclaim all warranties of any kind with respect
to third-party content, products, and services. Couchbase Inc. and its
affiliates will not be responsible for any loss, costs, or damages incurred due
to your access to or use of third-party content, products, or services.

The information contained herein is subject to change without notice and is not
warranted to be error-free. If you find any errors, please report them to us in
writing.