<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic xml:lang="en-us" id="topic3844">
   <title>Wrong documents or rows issue</title>
   <shortdesc>The wrong documents or rows are returned when querying with <codeph>include_docs=true</codeph>.</shortdesc>
   <body>
      <p>Imagine you have the following design document:</p>
      <codeblock><codeph>{
     "meta": {"id": "_design/test"},
     "views":
     {
         "view1": {
             "map": "function(doc, meta) { emit(meta.id,  doc.value); }"
         }
     }
 }
</codeph></codeblock>
      <p>And the bucket only has 2 documents, document <codeph>doc1</codeph> with JSON value
            <codeph>{"value": 1}</codeph>, and document <codeph>doc2</codeph> with JSON value
            <codeph>{"value": 2}</codeph>, you query the view initially with
            <codeph>stale=false</codeph> and <codeph>include_docs=true</codeph> and get:</p>
      <codeblock><codeph>&gt; curl -s 'http://localhost:9500/default/_design/test/_view/view1?include_docs=true&amp;stale=false' | json_xs
 {
    "total_rows" :
2,
    "rows" :
[
       {
          "value" : 1,
          "doc"
: {
             "json" : {
                "value" : 1
             },
             "meta" : {
                "flags" : 0,
                "expiration" : 0,
                "rev" : "1-000000367916708a0000000000000000",
                "id" : "doc1"
             }
          },
          "id"
: "doc1",
          "key"
: "doc1"
       },
       {
          "value" : 2,
          "doc"
: {
             "json" : {
                "value" : 2
             },
             "meta" : {
                "flags" : 0,
                "expiration" : 0,
                "rev" : "1-00000037b8a32e420000000000000000",
                "id" : "doc2"
             }
          },
          "id"
: "doc2",
          "key"
: "doc2"
       }
    ]
 }
</codeph></codeblock>
      <p>Later on you update both documents, such that document <codeph>doc1</codeph> has the JSON
         value <codeph>{"value": 111111}</codeph> and document <codeph>doc2</codeph> has the JSON
         value <codeph>{"value": 222222}</codeph>. You then query the view with
            <codeph>stale=update_after</codeph> (default) or <codeph>stale=ok</codeph> and get:</p>
      <codeblock><codeph>&gt; curl -s 'http://localhost:9500/default/_design/test/_view/view1?include_docs=true' | json_xs
 {
    "total_rows" :
2,
    "rows" :
[
       {
          "value" : 1,
          "doc"
: {
             "json" : {
                "value" : 111111
             },
             "meta" : {
                "flags" : 0,
                "expiration" : 0,
                "rev" : "2-0000006657aeed6e0000000000000000",
                "id" : "doc1"
             }
          },
          "id"
: "doc1",
          "key"
: "doc1"
       },
       {
          "value" : 2,
          "doc"
: {
             "json" : {
                "value" : 222222
             },
             "meta" : {
                "flags" : 0,
                "expiration" : 0,
                "rev" : "2-00000067e3ee42620000000000000000",
                "id" : "doc2"
             }
          },
          "id"
: "doc2",
          "key"
: "doc2"
       }
    ]
 }
</codeph></codeblock>
      <p>The documents included in each row don’t match the value field of each row, that is, the
         documents included are the latest (updated) versions but the index row values still reflect
         the previous (first) version of the documents.</p>
      <p>Why this behavior? Well, <codeph>include_docs=true</codeph> works at query time, for each
         row, to fetch from disk the latest revision of each document. There’s no way to include a
         previous revision of a document. Previous revisions are not accessible through the latest
         vbucket databases MVCC snapshots,
         and it’s not possible to find efficiently from which previous MVCC snapshots of a vbucket
         database a specific revision of a document is located. Further, vbucket database compaction
         removes all previous MVCC snapshots (document revisions). In short, this is a deliberate
         design limit of the database engine.</p>
      <p>The only way to ensure full consistency here is to include the documents themselves in the
         values emitted by the map function. Queries with <codeph>stale=false</codeph> are not 100%
         reliable either, as just after the index is updated and while rows are being streamed from
         disk to the client, document updates and deletes can still happen, resulting in the same
         behavior as in the given example.</p>
   </body>
   <related-links>
      <linklist>
         <link href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control" scope="external"
            format="html">
            <linktext>http://en.wikipedia.org/wiki/Multiversion_concurrency_control</linktext>
         </link>
      </linklist>
   </related-links>
</topic>
